import numpy as np
import random

# Compute the Euclidean distance matrix for a list of cities using Pythagoras Theorem
def calculate_distance_matrix(cities):
    #convert array for extra dimensions
    coordinates = np.array(cities) 
    #difference between cities
    difference = coordinates[:, np.newaxis, :] - coordinates[np.newaxis, :, :] 
    #taking the square root of the squared distances to get the Euclidean distances
    dist_matrix = np.sqrt(np.sum(difference ** 2, axis=2)) 
    #returns the distance matrix
    return dist_matrix

# Compute the total length of a given route
def compute_route_length(route, dist_matrix):
    #creating an index which will come back to initial point
    index = np.array(route + [route[0]])
    #sum of distances betweeen two consecutive points
    total_length = np.sum(dist_matrix[index[:-1], index[1:]])
    #return the total length of the route
    return total_length

# Generate a route using the greedy nearest neighbor heuristic
def nearest_neighbor_route(cities, dist_matrix):
    #getting the number of ciites
    num_cities = len(cities)
    #assigning unvisited cities
    unvisited = set(range(num_cities))
    #randomly selecting the starting city
    current_city = random.randrange(num_cities)
    #assign the path for starting city
    route = [current_city]
    #remove the visited city from the unvisited set and move to the next city in the route
    unvisited.remove(current_city)
    #start the while loop until all the cities are visited
    while unvisited:
        #find the nearest unvisited city near the current city
        next_city = min(unvisited, key=lambda city: dist_matrix[current_city, city])
        #add it to the route list
        route.append(next_city)
        #remove it from the set of unvisited cities
        unvisited.remove(next_city)
        #update the current city
        current_city = next_city
    #return the final route
    return route

# Initialize a population of routes
def create_initial_population(pop_size, cities, dist_matrix):
    #assign the path to the population which was generated by greedy nearest neighbor
    population = [nearest_neighbor_route(cities, dist_matrix)]
    #generate random population using permutation
    for _ in range(pop_size - 1):
        route = np.random.permutation(len(cities)).tolist()
        population.append(route)
    #return the generated population from the for loop
    return population

# Applying Ordered Crossover (OX) function
def ordered_crossover(parent_a, parent_b):
    #getting size of parent a
    size = len(parent_a)
    #initially child will have None size
    child = [None] * size
    #selecting random crossover point as start and end point by using range function
    start_pt, end_pt = sorted(random.sample(range(size), 2))
    #copy values from parent a to child
    child[start_pt:end_pt+1] = parent_a[start_pt:end_pt+1]
    #creating mask for the cities not in the copied values
    mask = np.isin(parent_b, child[start_pt:end_pt+1], invert=True)
    #take out the paths  from parent b which are not in child
    sorted_parent_b = np.array(parent_b)[mask]
    #find the pos of child which is still None
    fill_positions = [i for i, val in enumerate(child) if val is None]
    #convert it to a list
    fill_values = sorted_parent_b.tolist()
    #fill None pos with left out cities
    for pos, city in zip(fill_positions, fill_values):
        child[pos] = city
    #return the child routes
    return child

# Applying Partially Matched Crossover (PMX)
def partially_matched_crossover(parent1, parent2):
    #getting size of parent a
    size = len(parent1)
    #initially child will have None size
    child = [None] * size
    #selecting random crossover point as start and end point by using range function
    start, end = sorted(random.sample(range(size), 2))
    #copy values from parent a to child
    child[start:end+1] = parent1[start:end+1]
    #start mapping cities from parent2 to child to handle the errors
    for ind in range(start, end+1):
        if parent2[ind] not in child:
            val = parent2[ind]
            pos = ind
            while True:
                pos = parent2.index(parent1[pos])
                if child[pos] is None:
                    child[pos] = val
                    break
    #start filling the the left out pos from parent 2            
    for ind in range(size):
        if child[ind] is None:
            child[ind] = parent2[ind]
    #return the child routes
    return child

# Applying Mutation Operator
def mutation_operator(route, mutation_prob):
    #creating a copy of route to mutate
    mutated_route = route.copy()
    #using mutation based on the probability
    if random.random() < mutation_prob:
        #randomly selecting the route
        i, j = sorted(random.sample(range(len(mutated_route)), 2))
        #reversing the route
        mutated_route[i:j+1] = reversed(mutated_route[i:j+1])
    #return the mutated route after the mutation operation
    return mutated_route

# Ranking routes in the population based on their length
def rank_routes(population, dist_matrix):
    #fetching the total length for each route
    route_lengths = [compute_route_length(route, dist_matrix) for route in population]
    #get the index for sorting the length of each route
    ranked_indices = np.argsort(route_lengths)
    #returning the indices and the sorted lengths of routes in the population
    return ranked_indices, np.array(route_lengths)[ranked_indices]

# Evolve the population with help of elite size and generate the next generation
def evolve_population(population, elite_size, mutation_prob, dist_matrix, num_cities):
    #ranking the population based on total length
    ranked_indices, _ = rank_routes(population, dist_matrix)
    #slecting the best length of each route
    elites = [population[i] for i in ranked_indices[:elite_size]]
    #creating the pool with size of half the population
    selection_pool = [population[i] for i in ranked_indices[:len(population)//2]]
    #initialize the next generation
    next_gen = elites.copy()
    #calculate the number of offspring to be genrated
    num_offspring = len(population) - len(elites)
    #use for loop to fill up the next generation
    for _ in range(num_offspring):
        #random select the two parents
        parent1, parent2 = random.sample(selection_pool, 2)
        #choosing the crossover selection based on the number of cities
        if num_cities < 100:
            #for cities less than 100 we will use PMX since it works good for smaller number of datasets
            child = partially_matched_crossover(parent1, parent2)
        else:
            #for cities greater than 100 we will use OX since it works better for larger number of datasets
            child = ordered_crossover(parent1, parent2)
        #applying mutation operator to the child route
        child = mutation_operator(child, mutation_prob)
        #add the child route to the next generation
        next_gen.append(child)
    #return the next generation
    return next_gen

# Read city coordinates from a file
def load_cities(filename):
    with open(filename, 'r') as f:
        lines = f.readlines()
    num_cities = int(lines[0])
    city_coords = [tuple(map(int, line.strip().split())) for line in lines[1:num_cities+1]]
    return city_coords

# Write the optimal route to a file
def save_route(filename, route, length, cities):
    with open(filename, 'w') as f:
        f.write(f"{length:.3f}\n")
        for city_idx in route + [route[0]]:
            city = cities[city_idx]
            f.write(f"{city[0]} {city[1]} {city[2]}\n")

# Improve the route using an optimized 2-opt local search algorithm
def two_opt_optimization(route, dist_matrix, max_iters):
    #find the  total length of the starting point
    best_distance = compute_route_length(route, dist_matrix)
    #save it as the best path
    best_route = route.copy()
    #get the number of cities in the path
    size = len(best_route)
    #start the iteration from zero
    iteration = 0
    #use while lopp until np improvement found  or max iteration reached
    while iteration < max_iters:
        improved = False
        #iterating through all the possible routes
        for i in range(1, size - 2):
            for k in range(i + 1, size - 1):
                #find the change in length of the routes and swap it
                delta = (dist_matrix[best_route[i - 1], best_route[k]] +
                         dist_matrix[best_route[i], best_route[k + 1]] -
                         dist_matrix[best_route[i - 1], best_route[i]] -
                         dist_matrix[best_route[k], best_route[k + 1]])
                #if swapping gives the better route
                if delta < -1e-6:
                    #do 2-opt swapping by reversingg the i and k
                    best_route[i:k+1] = reversed(best_route[i:k+1])
                    #update the best distance
                    best_distance += delta
                    improved = True
                    break  # Exit inner loop
            if improved:
                break  # Exit outer loop
        if not improved:
            break
        #increment the iteration by 1
        iteration += 1
    #return the best route after optimization
    return best_route

# Main function to execute the Genetic Algorithm for Travelling Salesman Problem
def main_function():
    #initialize input and output file name
    input_file = "input.txt"
    output_file = "output.txt"
    #take coordinates from the input file
    cities = load_cities(input_file)
    #take number of cities
    num_cities = len(cities)
    #find euclidean distance matrix
    dist_matrix = calculate_distance_matrix(cities)

    # Adjust parameters based on the number of cities to reduce or optimize execution time
    if num_cities <= 100: #if the number of cities is less than or equals 100
        pop_size = 100
        num_generations = 150
        elite_size = 10
        mutation_prob = 0.02
        two_opt_iters = 50
    elif num_cities <= 300: #if the number of cities is less than or equals 300
        pop_size = 80
        num_generations = 100
        elite_size = 8
        mutation_prob = 0.02
        two_opt_iters = 30
    else: # for larger data sets
        pop_size = 50
        num_generations = 80
        elite_size = 5
        mutation_prob = 0.01
        two_opt_iters = 20
    
    #create initial population
    population = create_initial_population(pop_size, cities, dist_matrix)

    #change teh population over the given generations
    for _ in range(num_generations):
        population = evolve_population(population, elite_size, mutation_prob, dist_matrix, num_cities)

    #rank the final population as best fit
    ranked_indices, _ = rank_routes(population, dist_matrix)
    best_route = population[ranked_indices[0]]
    #improve it using 2-opt local search heuristics
    optimized_route = two_opt_optimization(best_route, dist_matrix, max_iters=two_opt_iters)
    #find the total length of optimized path
    best_length = compute_route_length(optimized_route, dist_matrix)
    #save the optimal route to the output file  with the total length of the route as the first line
    save_route(output_file, optimized_route, best_length, cities)

# Call the Genetic Algorithm Function
if __name__ == "__main__":
    main_function()